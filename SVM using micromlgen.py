# -*- coding: utf-8 -*-
"""FIX- using micromlgen lib.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bp6oDPds6vUaa-EzIPGPnfAs7MNTBpEX
"""

from google.colab import drive
drive.mount('/content/drive')

!apt-get update
!apt-get install -y libglu1-mesa

!pip install micromlgen

import pandas as pd

# Load dataset
data = pd.read_csv('/content/drive/MyDrive/SKRIPSII/CODE PROGRAM/COBA/EMG-data.csv/emg-data-10-subjects.csv')
data.head()

import numpy as np
import pandas as pd
from sklearn.model_selection import KFold
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics import accuracy_score, classification_report
from sklearn.svm import SVC
from joblib import dump
from scipy.ndimage import gaussian_filter
from imblearn.over_sampling import SMOTE
from micromlgen import port

# Fungsi untuk menerapkan Gaussian Filter
def apply_gaussian_filter(data, sigma=1.6, kernel=11):
    return gaussian_filter(data, sigma=sigma)

# Fungsi untuk menghitung WL (Waveform Length)
def calculate_wl(data):
    # Hitung WL per kanal secara independen
    return np.sum(np.abs(np.diff(data, axis=0)), axis=0)

# Fungsi untuk menerapkan sliding window dan menghitung WL
def apply_sliding_window_wl(data, window_size=300, stride=1):
    n_samples, n_features = data.shape
    wl_features = []

    for start in range(0, n_samples - window_size + 1, stride):
        window = data[start:start + window_size, :]
        wl = calculate_wl(window)
        wl_features.append(wl)

    return np.array(wl_features)

# Misalkan data telah dimuat dalam DataFrame 'data'
X = data.iloc[:, :-2].values
y = data.iloc[:, -2].values

X_filtered = apply_gaussian_filter(X)
X_wl = apply_sliding_window_wl(X_filtered)

X_min = X_wl.min()
X_max = X_wl.max()
X_normalized = ((X_wl - X_min) / (X_max - X_min)) * 255

"""# Convert to uint8 data type
X_normalized = X_normalized.astype(np.uint8)"""

df_features = pd.DataFrame(X_normalized)
df_features['class'] = y[:len(df_features)]
csv_filename = 'extracted_features.csv'
df_features.to_csv(csv_filename, index=False)

kf = KFold(n_splits=5, shuffle=True, random_state=42)
fold = 1
accuracies = []
smote = SMOTE(random_state=42)

for train_index, test_index in kf.split(X_normalized):
    print(f'Fold {fold}')
    X_train, X_test = X_normalized[train_index], X_normalized[test_index]
    y_train, y_test = y[train_index], y[test_index]
    X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

    svm_model = SVC(kernel='rbf', C=10, gamma=0.001)  # Langsung menggunakan SVC
    start_time = time.time()
    svm_model.fit(X_train_resampled, y_train_resampled)
    end_time = time.time()

    y_pred = svm_model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    accuracies.append(accuracy)
    print(f'Akurasi: {accuracy}')
    print(f'Waktu yang dibutuhkan untuk fold {fold}: {end_time - start_time:.4f} seconds')

    model_filename = f'svm_model_fold{fold}.joblib'
    dump(svm_model, model_filename)

    header_filename = f'svm_model_fold{fold}.h'
    with open(header_filename, 'w') as header_file:
        header_content = port(svm_model, compressed=True)  # Menggunakan fungsi port dari micromlgen
        header_file.write(header_content)

    print(f'Model SVM dalam format .h disimpan untuk fold {fold}.')
    fold += 1

mean_accuracy = np.mean(accuracies)
print(f'Mean Accuracy: {mean_accuracy}')

import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix

# Buat confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)

# Visualisasikan confusion matrix
plt.figure(figsize=(10, 7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=np.unique(y), yticklabels=np.unique(y))
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

# Cetak classification report
report = classification_report(y_test, y_pred)
print("Classification Report:\n", report)

"""Konversikan file .npy menjadi array C/C++"""

import numpy as np
from joblib import load

# Fungsi untuk menguji model dengan input data dari user
def test_model(model, input_data):
    """Menggunakan model yang telah dilatih untuk memprediksi kelas berdasarkan input data."""
    # Ubah input data menjadi array
    input_array = np.array(input_data).reshape(1, -1)

    # Prediksi kelas menggunakan model
    predicted_class = model.predict(input_array)

    return predicted_class

# Load model yang telah disimpan (misalnya dari fold terakhir)
model = load('svm_model_fold4.joblib')

# Tampilkan pesan contoh input dan minta user memasukkan data
print("Masukkan 8 channel input data:")
user_input = list(map(float, input().split()))

# Uji model dengan input dari user
predicted_class = test_model(model, user_input)

# Tampilkan hasil prediksi kelas
print(f"Hasil prediksi kelas: {predicted_class[0]}")